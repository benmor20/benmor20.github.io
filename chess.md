# Chess Not Checkers

During my Principles of Integrated Engineering class my sophomore year, I worked with a group to make an automatic chess board: a physical board with the ability to move the pieces itself, so a person can play against a chess AI in real life. The board itself concealed an electromagnet mounted on a two-axis gantry system controlled by an Arduino. The Arduino was hooked up to a laptop which could run a more complicated Python script with a chess AI in it. With stepper motors, we were able to precisely control the position of the electromagnet, and then could turn the magnet on and off to move the magnetic pieces around the board. Additionally, we created an array of hall effect sensors immediately under the board, which could detect a human moving pieces themselves. For full project details, visit the [Chess not Checkers site](https://olincollege.github.io/pie-2021-03/Chess-not-Checkers/).

## My Work

I focused on the control system for this project. I wrote the Arduino code and low-level Python code so the two computers could communicate and coordinate movements. I built a custom communication protocol to minimize the amount of data that would need to be sent over the serial bus while still allowing for full control of the two motors, the electromagnet, and sensor readings.

The [Arduino code](https://github.com/gabbyblake/PIE-Final-Project-Chess/blob/fa2f870c178225c281f9ef2c957a9d6db1dc1526/Arduino/SerialConnection/SerialConnection.ino) was mostly a parser for each command, along with logic to read from the hall effect sensor array and send that information over the serial when needed.

Additionally, I wrote [a series of classes in Python](https://github.com/gabbyblake/PIE-Final-Project-Chess/tree/fa2f870c178225c281f9ef2c957a9d6db1dc1526/PythonChessController/src/hardware) to facilitate sending and receiving commands from the Arduino with ease. The classes ranged from an absolute low-level representation of [the Serial Connection](https://github.com/gabbyblake/PIE-Final-Project-Chess/blob/fa2f870c178225c281f9ef2c957a9d6db1dc1526/PythonChessController/src/hardware/serial_protocol.py) to [types of sensors](https://github.com/gabbyblake/PIE-Final-Project-Chess/blob/fa2f870c178225c281f9ef2c957a9d6db1dc1526/PythonChessController/src/hardware/devices.py), and finally [motors and the gantry system as a whole](https://github.com/gabbyblake/PIE-Final-Project-Chess/blob/fa2f870c178225c281f9ef2c957a9d6db1dc1526/PythonChessController/src/hardware/drive_system.py). With these classes, it was possible to give a single command, say, "Move to A5", and the background updates would handle all of the specific commands needed to make that movement happen without blocking the rest of the program execution.

While, at the end of the project, we were not able to play a full game of chess, the communication system I developed was a success. Once the classes were built, the lines of code needed to move a piece were very short and easy to write. This allowed for speedy development once all of the subsystems were ready to go.
